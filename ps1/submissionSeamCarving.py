
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# Edit SeamCarving.ipynb instead.
import numpy as np
import matplotlib.pyplot as plt
from scipy import ndimage, signal
from imageio import imread, imsave

def  rgb2gray(img):
    """
    Converts an RGB image into a greyscale image

    Input: ndarray of an RGB image of shape (H x W x 3)
    Output: ndarray of the corresponding grayscale image of shape (H x W)

    """

    if(img.ndim != 3 or img.shape[-1] != 3):
        print("Invalid image! Please provide an RGB image of the shape (H x W x 3) instead.".format(img.ndim))
        return None

    return np.dot(img[...,:3], [0.2989, 0.5870, 0.1140])

def compute_gradients(img):
    """
    Computes the gradients of the input image in the x and y direction using a
    differentiation filter.

    ##########################################################################
    # TODO: Design a differentiation filter and update the docstring. Stick  #
    # to a pure differentiation filter for this assignment.                  #
    # Hint: Look at Slide 14 from Lecture 3: Gradients.                      #
    ##########################################################################

    Input: Grayscale image of shape (H x W)
    Outputs: gx, gy gradients in x and y directions respectively

    """
    # gx = gy = np.zeros_like(img, np.float64)
    deriv_x_filter = np.array([[1, 0, -1],
                               [1, 0, -1],
                               [1, 0, -1]])
    deriv_y_filter = np.array([[1, 1, 1],
                               [0, 0, 0],
                               [-1, -1, -1]])
    gx = ndimage.correlate(img, deriv_x_filter, np.float64, 'constant')
    gy = ndimage.correlate(img, deriv_y_filter, np.float64, 'constant')


    ##########################################################################
    # TODO: Design a pure differentiation filter and use correlation to      #
    # compute the gradients gx and gy. You might have to try multiple        #
    # filters till the test below passes. All the tests after will fail if   #
    # this one does not pass.                                                #
    ##########################################################################
    return gx, gy

def energy_image(img):
    """
    Computes the energy of the input image according to the energy function:

        e(I) = abs(dI/dx) + abs(dI/dy)

    Use compute_gradients() to help you calculate the energy image. Remember to normalize
    energyImage by dividing it by max(energyImage).

    Input: image of the form (H x W) or (H x w x 3)
    Output: array of energy values of the image computed according to the energy function.

    """

    if len(img.shape) == 3:
      img = rgb2gray(img)

    gx, gy = compute_gradients(img)


    energyImage = np.absolute(gx) + np.absolute(gy)

    energyMax = np.amax(energyImage)

    energyImage = energyImage / energyMax



    ##########################################################################
    # TODO: Compute the energy of input using the defined energy function.   #                                             #
    ##########################################################################

    return energyImage

def cumulative_minimum_energy_map(energyImage, seamDirection):
    """
    Calculates the cumulative minim energy map according to the function:

        M(i, j) = e(i, j) + min(M(i-1, j-1), M(i-1, j), M(i-1, j+1))

    Inputs:
        energyImage: Results of passign the input image to energy_image()
        seamDirection: 'HORIZONTAL' or 'VERTICAL'

    Output: cumulativeEnergyMap

    """

    cumulativeEnergyMap = np.zeros_like(energyImage)

    h, w = energyImage.shape

    if seamDirection == 'HORIZONTAL':
      cumulativeEnergyMap[:, 0] = energyImage[:, 0]
      for i in range(1, w):
        for j in range(0, h):
          min_index = np.argmin(cumulativeEnergyMap[max(j - 1, 0):j+2, i - 1])
          min_energy = cumulativeEnergyMap[min_index + max(j - 1, 0), i - 1]

          cumulativeEnergyMap[j, i] = energyImage[j, i] + min_energy
    else:
      cumulativeEnergyMap[0, :] = energyImage[0, :]
      for i in range(1, h):
        for j in range(0, w):
          min_index = np.argmin(cumulativeEnergyMap[i - 1, max(j-1, 0):j+2])
          min_energy = cumulativeEnergyMap[i - 1, min_index + max(j - 1, 0)]

          cumulativeEnergyMap[i, j] = energyImage[i, j] + min_energy


    ##########################################################################
    # TODO: Compute the cumulative minimum energy map in the input           #
    # seamDirection for the input energyImage. It is fine it is not fully    #
    # vectorized.                                                            #
    ##########################################################################

    return cumulativeEnergyMap

def find_optimal_vertical_seam(cumulativeEnergyMap):
    """
    Finds the least connected vertical seam using a vertical cumulative minimum energy map.

    Input: Vertical cumulative minimum energy map.
    Output:
        verticalSeam: vector containing column indices of the pixels in making up the seam.

    """

    verticalSeam = [0]*cumulativeEnergyMap.shape[0]

    verticalSeam[-1] = np.argmin(cumulativeEnergyMap[-1])

    for i in range(len(verticalSeam) - 2, -1, -1):
      j = verticalSeam[i + 1]

      if j <= 0:
        verticalSeam[i] = np.argmin(cumulativeEnergyMap[i, j:j+2])
      else:
        verticalSeam[i] =  j + np.argmin(cumulativeEnergyMap[i, j-1:j+2]) - 1


    ##########################################################################
    # TODO: Find the minimal connected vertical seam using the input         #
    # cumulative minimum energy map.                                         #
    ##########################################################################

    return verticalSeam

def find_optimal_horizontal_seam(cumulativeEnergyMap):
    """
    Finds the least connected horizontal seam using a horizontal cumulative minimum energy map.

    Input: Horizontal cumulative minimum energy map.
    Output:
        horizontalSeam: vector containing row indices of the pixels in making up the seam.

    """
    horizontalSeam = [0]*cumulativeEnergyMap.shape[1]

    horizontalSeam[-1] = np.argmin(cumulativeEnergyMap[:, -1])

    for i in range(len(horizontalSeam) - 2, -1, -1):
      j = horizontalSeam[i + 1]

      if j <= 0:
        horizontalSeam[i] = np.argmin(cumulativeEnergyMap[j:j+2, i])
      else:
        horizontalSeam[i] = j + np.argmin(cumulativeEnergyMap[j-1:j+2, i]) - 1

    ##########################################################################
    # TODO: Find the minimal connected horizontal seam using the input       #
    # cumulative minimum energy map.                                         #
    ##########################################################################

    return horizontalSeam

def reduce_width(img, energyImage):
    """
    Removes pixels along a seam, reducing the width of the input image by 1 pixel.

    Inputs:
        img: RGB image of shape (H x W x 3) from which a seam is to be removed.
        energyImage: The energy image of the input image.

    Outputs:
        reducedColorImage: The input image whose width has been reduced by 1 pixel
        reducedEnergyImage: The energy image whose width has been reduced by 1 pixel
    """
    reducedEnergyImageSize = (energyImage.shape[0], energyImage.shape[1] - 1)
    reducedColorImageSize = (img.shape[0], img.shape[1] - 1, 3)

    CEMVertical = cumulative_minimum_energy_map(energyImage, 'VERTICAL')
    vertical_seam = find_optimal_vertical_seam(CEMVertical)

    reducedColorImage = np.zeros(reducedColorImageSize)
    reducedEnergyImage = np.zeros(reducedEnergyImageSize)

    for i in range(reducedEnergyImage.shape[0]):
      delete_index = vertical_seam[i]
      reducedColorImage[i, :] = np.delete(img[i, :], delete_index, 0)
      reducedEnergyImage[i, :] = np.delete(energyImage[i, :], delete_index, 0)


    ##########################################################################
    # TODO: Compute the cumulative minimum energy map and find the minimal   #
    # connected vertical seam. Then, remove the pixels along this seam.      #
    ##########################################################################

    return reducedColorImage, reducedEnergyImage

def reduce_height(img, energyImage):
    """
    Removes pixels along a seam, reducing the height of the input image by 1 pixel.

    Inputs:
        img: RGB image of shape (H x W x 3) from which a seam is to be removed.
        energyImage: The energy image of the input image.

    Outputs:
        reducedColorImage: The input image whose height has been reduced by 1 pixel
        reducedEnergyImage: The energy image whose height has been reduced by 1 pixel
    """

    reducedEnergyImageSize = tuple((energyImage.shape[0] - 1, energyImage.shape[1]))
    reducedColorImageSize = tuple((img.shape[0] - 1, img.shape[1], 3))

    CEMHorizontal = cumulative_minimum_energy_map(energyImage, 'HORIZONTAL')
    horizontal_seam = find_optimal_horizontal_seam(CEMHorizontal)

    reducedColorImage = np.zeros(reducedColorImageSize)
    reducedEnergyImage = np.zeros(reducedEnergyImageSize)

    for i in range(reducedEnergyImage.shape[1]):
      delete_index = horizontal_seam[i]
      reducedColorImage[:, i] = np.delete(img[:, i], delete_index, 0)
      reducedEnergyImage[:, i] = np.delete(energyImage[:, i], delete_index, 0)

    ##########################################################################
    # TODO: Compute the cumulative minimum energy map and find the minimal   #
    # connected horizontal seam. Then, remove the pixels along this seam.    #
    ##########################################################################

    return reducedColorImage, reducedEnergyImage

def seam_carving_reduce_width(img, reduceBy):
    """
    Reduces the width of the input image by the number pixels passed in reduceBy.

    Inputs:
        img: Input image of shape (H x W X 3)
        reduceBy: Positive non-zero integer indicating the number of pixels the width
        should be reduced by.

    Output:
        reducedColorImage: The result of removing reduceBy number of vertical seams.
    """

    reducedColorImage = img  #crops the image
    reducedEnergyImage = energy_image(reducedColorImage)

    ##########################################################################
    # TODO: For the Prague image, write a few lines of code to call the      #
    # we have written to find and remove 100 vertical seams                  #
    ##########################################################################

    for i in range(reduceBy):
      reducedColorImage, reducedEnergyImage = reduce_width(reducedColorImage, reducedEnergyImage)

    return reducedColorImage.astype(np.uint8)

def seam_carving_reduce_height(img, reduceBy):
    """
    Reduces the height of the input image by the number pixels passed in reduceBy.

    Inputs:
        img: Input image of shape (H x W X 3)
        reduceBy: Positive non-zero integer indicating the number of pixels the
        height should be reduced by.

    Output:
        reducedColorImage: The result of removing reduceBy number of horizontal
        seams.
    """

    reducedColorImage = img  #crops the image
    reducedEnergyImage = energy_image(reducedColorImage)

    ##########################################################################
    # TODO: For the Prague image, write a few lines of code to call the      #
    # we have written to find and remove 100 horizontal seams.               #
    ##########################################################################

    for i in range(reduceBy):
      reducedColorImage, reducedEnergyImage = reduce_height(reducedColorImage, reducedEnergyImage)

    return reducedColorImage.astype(np.uint8)